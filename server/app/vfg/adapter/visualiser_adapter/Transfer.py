"""This component transfers the result generated by Predicate Solver into the final visualisation file"""
#-----------------------------Authorship-----------------------------------------
#-- Authors  : Gang
#-- Group    : Planning Visualisation
#-- Date     : 13/August/2018
#-- Version  : 1.0
#--------------------------------------------------------------------------------
#-----------------------------Reviewer-------------------------------------------
#-- Authors  : Sharukh
#-- Group    : Planning Visualisation
#-- Date     : 27/August/2018
#-- Version  : 1.0
#--------------------------------------------------------------------------------
import copy
import os
import sys
sys.path.append(os.path.abspath(os.path.dirname(__file__) + '/' +"vfg/solver"))
import Solver
import Initialise
import json

# This python file aims to finish step 4 in our solution
#######################################################
# Input File: the reuslt of initialise componenet
# Input File: the result of solver componenet
# Output : Visualisation File
#######################################################

def transfer(one_stage, initialobjects, panel_size,shift, padding=20):
    """This function converts the dictionary into the info needed in visualisation file.
    Args:
        one_stage(Dict): a dictionary contains the locaiton of objects for one stage/step
        initialise_objects(List): the list to store all objects that needed to be
                                  shown in the animation profile.
        panel_width(int): the width of the animation panel.
        panel_height(int): the height of the animation panel.
    Returns:
        transfered_stage(Dict): the dict to store all info needed in visualisation file.
    """
    # list that stores object name
    transfered_stage = {}
    temp = []
    # dict that stores new position info
    position_dic = {"minX": "",
                    "maxX": "",
                    "minY": "",
                    "maxY": ""}
    # new position info
    min_x = 0.0
    max_x = 0.0
    min_y = 0.0
    max_y = 0.0
    # generate new json file
    for obj in one_stage:
        if "x" not in one_stage[obj] or "y" not in one_stage[obj]:
            continue
        one_stage[obj]
        # get all information about position
        x_num = one_stage[obj]["x"]
        y_num = one_stage[obj]["y"]
        width = one_stage[obj]["width"]
        # set the panel with after we got the panel width
        if type(width) is str:
            if width.lower() == "panel_size":
                width = panel_size - 2 * padding
                one_stage[obj]["width"]=width
        height = one_stage[obj]["height"]
        # transfer the position info into position needed in Unity
        min_x = (x_num + padding+shift) / panel_size
        max_x = (x_num+shift + width + padding) / panel_size
        min_y = (y_num+shift+padding) / panel_size
        max_y = (y_num +shift+ height+padding) / panel_size
        position_dic["minX"] = round(min_x, 3)
        position_dic["maxX"] = round(max_x, 3)
        position_dic["minY"] = round(min_y, 3)
        position_dic["maxY"] = round(max_y, 3)
        # update the old dict
        one_stage[obj].update(position_dic)
        temp.append(one_stage[obj])
    transfered_stage["visualSprites"] = temp
    return transfered_stage


def get_panel_size(result, padding=20):
    """This function will for loop all the objects in the visualisaiton dictionary,
    and try to find the max_x and max_y of the panel.
    .........max_y
    .        .
    .        .
    .        .
    ........max_x
    Args:
        result: visualisation dictionary that contain the location of each object
                for different stages.
        padding: padding between the object and the edge of the screen.
    Returns:
        max_x: the max x of objects.
        max_y: the max y of objects.

    """
    lists = result["visualStages"]
    max_x = 0
    max_y = 0
    min_x = 0
    min_y = 0
    for stage in lists:
        stageitems = stage["visualSprites"]

        for item in stageitems:
            if "x" not in stageitems[item] or "y" not in stageitems[item]:
                continue
            x = stageitems[item]["x"]
            y = stageitems[item]["y"]

            if type(stageitems[item]["width"]) is int:
                new_x = x + stageitems[item]["width"]
                if new_x > max_x:
                    max_x = new_x
                if x < min_x:
                    min_x = x
            if type(stageitems[item]["height"]) is int:
                new_y = y + stageitems[item]["height"]
                if new_y > max_y:
                    max_y = new_y
                if y < min_y:
                    min_y = y
    shift=max(abs(min_x), abs(min_y))
    panel_size=max(max_x, max_y)+ shift+ 2 * padding
    return panel_size, shift

def generate_visualisation_file(result, object_list,animation_profile,actionlist):
    """This function generates the visualisation file.
    Args:
        result(Dict): the dict to be converted.
        object_list: list of all the name of the objects.
    """
    final = {"visualStages": []}
    one_stage = {}
    sprite_list = []
    lists = result["visualStages"]
    panel_size,shift= get_panel_size(result)
    index = 0
    for item in lists:
        one_stage = item["visualSprites"]
        transfered_stage=transfer(one_stage, object_list, panel_size,shift)
        transfered_stage["stageName"]=item["stageName"]
        transfered_stage["stageInfo"]=item["stageInfo"]
        if (index == len(actionlist)):
            transfered_stage["isFinal"] = "true"
        else:
            transfered_stage["isFinal"] = "false"
        sprite_list.append(transfered_stage)
        index = index + 1
    final["visualStages"] = sprite_list
    final["subgoalPool"] = generate_subgoal(result["subgoals"])["subgoalPool"]
    final["subgoalMap"] = generate_subgoal(result["subgoals"])["subgoalMap"]
    final["transferType"]=1
    final["imageTable"]=animation_profile["imageTable"]
    final["message"] = ""
    # print(generate_subgoal(result["subgoals"]))
    return final


#######################################################
# This function is designed to combine the subgoal
# with the same name into one dict.
def dedupe(items):
    """The function is to convert subgoal list into correct format
           Args:
               items: subgoal list
           Returns:
               subgoal list in correct format
       """
    seen = []
    result = []

    for item in items:
        if item["name"] not in seen:
            seen.append(item["name"])
    for se in seen:
        numlist = []
        namelist = []
        objectlist = []
        for item in items:
            if item["name"] == se:
                numlist.append(item["stepNum"])
                namelist.append(item["stepName"])
                objectlist = item["objects"]
        result.append({"name":se,"stepNum":numlist,"stepName": namelist,"objects":objectlist})

    return result

# def generate_subgoal(subgoals):
#     """This function transfers the subgoal structure into the final one
#     """
#
#     subgoal_pool = []
#     for subgoal in dedupe(subgoals):
#         temp = {subgoal["name"]: subgoal["objects"]}
#
#         subgoal_pool.append(temp)
#     print(subgoal_pool)
#     step_list = []
#     for subgoal in subgoals:
#         if subgoal["stepNum"] not in step_list:
#             step_list.append(subgoal["stepNum"])
#
#     subgoal_map = []
#     for step in step_list:
#         value = []
#         for subgoal in subgoals:
#             if subgoal["stepNum"] == step:
#
#                 value.append(subgoal["name"])
#         temp = {step: value}
#         subgoal_map.append(temp)
#     subgoal_transfer = {"subgoalPool": subgoal_pool,"subgoalMap": subgoal_map}
#     return subgoal_transfer
def generate_subgoal(subgoals):
    """This function transfers the subgoal structure into the final one
    """
    m_keys = []
    m_values = []
    for subgoal in dedupe(subgoals):
        m_keys.append(subgoal["name"])
        m_values.append(subgoal["objects"])
    subgoal_pool = {"m_keys": m_keys, "m_values": m_values}

    step_list = []
    values = []
    for subgoal in subgoals:
        if subgoal["stepNum"] not in step_list:
            step_list.append(subgoal["stepNum"])

    # print(step_list)
    for step in step_list:
        value = []
        for subgoal in subgoals:
            if subgoal["stepNum"] == step:
                value.append(subgoal["name"])
        values.append(value)
    pool_map = {"m_keys": step_list,"m_values":values}
    subgoal_transfer = {"subgoalPool": subgoal_pool,"subgoalMap": pool_map}
    # print(pool_map)
    return subgoal_transfer

def get_visualisation_json(predicates, animation_profile,actionlist,problem_dic):
    """This function is the main function of this module, it will call the other functions
    to manipulate the visualisation file for the unity visualiser.

    Args:
        predicates(Dictionary): an dictionary contains the 1.objects name and the 2.predicates for
                                each stages.
        animation_profile(Dictionary): the dict to store all information in animation profile.

    """

    object_list = copy.deepcopy(predicates["objects"])
    stages = copy.deepcopy(predicates["stages"])
    # subgoals = copy.deepcopy(predicates["subgoals"])
    predicates_rules = animation_profile["predicates_rules"]
    objects_dic = Initialise.initialise_objects(object_list, animation_profile)
    Solver.add_fixed_objects(objects_dic, animation_profile)

    space = {}
    space["distributex"] = {}
    space["distribute_within_objects_vertical"] = {}
    space["apply_smaller"] = {}
    space["align_middle"] = {}
    space["distribute_within_objects_horizontal"] = {}
    space["distribute_grid_around_point"] = {}
    space["distributey"] = {}
    space["calculate_label"] = {}
    space["draw_line"] = {}
    result = Solver.solve_all_stages(stages, objects_dic, predicates_rules, space,actionlist,problem_dic)
    # print(result["subgoals"])
    return generate_visualisation_file(result, list(objects_dic.keys()),animation_profile,actionlist)